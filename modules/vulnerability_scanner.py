"""
Vulnerability Scanner Module
Performs basic vulnerability assessment and security checks
"""

import asyncio
import aiohttp
import ssl
from typing import Dict, List, Any, Optional
from datetime import datetime
import re
from urllib.parse import urljoin, urlparse
import json

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""

    def __init__(self, config):
        self.config = config
        self.session = None

        # Common vulnerability test payloads
        self.xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "javascript:alert('XSS')",
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>'
        ]

        self.sql_payloads = [
            "' OR '1'='1",
            '" OR "1"="1',
            "' OR 1=1 --",
            "' UNION SELECT NULL--",
            "1' AND 1=1#"
        ]

        self.lfi_payloads = [
            "../../../../etc/passwd",
            "../../../../windows/system32/drivers/etc/hosts",
            "../../../etc/shadow",
            "....//....//....//etc/passwd"
        ]

        # Common vulnerable paths and files
        self.sensitive_paths = [
            '/admin',
            '/administrator', 
            '/backup',
            '/backups',
            '/config',
            '/database',
            '/db',
            '/debug',
            '/dev',
            '/old',
            '/temp',
            '/test',
            '/uploads',
            '/.env',
            '/.git',
            '/config.php',
            '/phpinfo.php',
            '/server-status',
            '/server-info'
        ]

    async def __aenter__(self):
        """Async context manager entry"""
        connector = aiohttp.TCPConnector(ssl=ssl.create_default_context())
        timeout = aiohttp.ClientTimeout(total=30)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()

    async def scan(self, target: str) -> List[Dict[str, Any]]:
        """
        Perform comprehensive vulnerability scan

        Args:
            target: URL or domain to scan

        Returns:
            List of discovered vulnerabilities
        """
        if not target.startswith(('http://', 'https://')):
            target = f'https://{target}'

        vulnerabilities = []

        async with self:
            try:
                # Information disclosure checks
                info_vulns = await self._check_information_disclosure(target)
                vulnerabilities.extend(info_vulns)

                # Sensitive file/directory exposure
                path_vulns = await self._check_sensitive_paths(target)
                vulnerabilities.extend(path_vulns)

                # Basic injection vulnerability checks
                injection_vulns = await self._check_injection_vulnerabilities(target)
                vulnerabilities.extend(injection_vulns)

                # HTTP method checks
                method_vulns = await self._check_http_methods(target)
                vulnerabilities.extend(method_vulns)

                # Security configuration checks
                config_vulns = await self._check_security_configurations(target)
                vulnerabilities.extend(config_vulns)

            except Exception as e:
                vulnerabilities.append({
                    'type': 'Scan Error',
                    'severity': 'INFO',
                    'target': target,
                    'description': f'Vulnerability scan encountered error: {str(e)}',
                    'recommendation': 'Manual verification recommended',
                    'timestamp': datetime.now().isoformat()
                })

        return vulnerabilities

    async def _check_information_disclosure(self, target: str) -> List[Dict[str, Any]]:
        """Check for information disclosure vulnerabilities"""
        vulnerabilities = []

        try:
            async with self.session.get(target) as response:
                headers = dict(response.headers)
                content = await response.text()

                # Server header analysis
                server = headers.get('server', '').lower()
                if any(keyword in server for keyword in ['apache/', 'nginx/', 'iis/', 'lighttpd/']):
                    if re.search(r'\d+\.\d+', server):  # Version numbers
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'LOW',
                            'target': target,
                            'description': f'Server header reveals version information: {headers.get("server")}',
                            'evidence': headers.get('server'),
                            'recommendation': 'Configure server to hide version information',
                            'cwe': 'CWE-200',
                            'timestamp': datetime.now().isoformat()
                        })

                # X-Powered-By header
                powered_by = headers.get('x-powered-by', '')
                if powered_by:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'LOW',
                        'target': target,
                        'description': f'X-Powered-By header reveals technology stack: {powered_by}',
                        'evidence': powered_by,
                        'recommendation': 'Remove X-Powered-By header or configure to hide technology details',
                        'cwe': 'CWE-200',
                        'timestamp': datetime.now().isoformat()
                    })

                # Look for error messages in content
                error_patterns = [
                    r'mysql.*error',
                    r'postgresql.*error',
                    r'oracle.*error',
                    r'microsoft.*error',
                    r'warning:.*mysql',
                    r'php.*error',
                    r'asp\.net.*error',
                    r'stack trace',
                    r'exception.*details'
                ]

                content_lower = content.lower()
                for pattern in error_patterns:
                    if re.search(pattern, content_lower):
                        vulnerabilities.append({
                            'type': 'Error Message Disclosure',
                            'severity': 'MEDIUM',
                            'target': target,
                            'description': f'Error message pattern detected: {pattern}',
                            'recommendation': 'Implement proper error handling and disable debug mode',
                            'cwe': 'CWE-209',
                            'timestamp': datetime.now().isoformat()
                        })
                        break  # Avoid multiple matches

        except Exception as e:
            pass  # Continue with other checks

        return vulnerabilities

    async def _check_sensitive_paths(self, target: str) -> List[Dict[str, Any]]:
        """Check for sensitive file and directory exposure"""
        vulnerabilities = []

        # Limit concurrent requests to avoid overwhelming the server
        semaphore = asyncio.Semaphore(5)

        async def check_path(path):
            async with semaphore:
                try:
                    test_url = urljoin(target, path)
                    async with self.session.get(test_url, allow_redirects=False) as response:
                        if response.status in [200, 403]:  # Found or Forbidden (but exists)
                            content = await response.text()

                            severity = 'MEDIUM'
                            description = f'Sensitive path accessible: {path}'

                            # Check for directory listing
                            if 'index of' in content.lower() or '<pre>' in content.lower():
                                severity = 'HIGH'
                                description = f'Directory listing enabled at: {path}'

                            # Check for specific sensitive files
                            elif path.endswith('.env'):
                                if 'password' in content.lower() or 'secret' in content.lower():
                                    severity = 'CRITICAL'
                                    description = f'Environment file exposed containing credentials: {path}'

                            elif path.endswith('phpinfo.php'):
                                if 'phpinfo()' in content:
                                    severity = 'HIGH' 
                                    description = f'PHP info page exposed: {path}'

                            return {
                                'type': 'Sensitive Path Exposure',
                                'severity': severity,
                                'target': test_url,
                                'description': description,
                                'status_code': response.status,
                                'recommendation': f'Restrict access to {path} or remove if unnecessary',
                                'cwe': 'CWE-200',
                                'timestamp': datetime.now().isoformat()
                            }

                except Exception:
                    pass  # Ignore connection errors

                return None

        # Create tasks for all path checks
        tasks = [check_path(path) for path in self.sensitive_paths]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Collect valid vulnerabilities
        for result in results:
            if result and not isinstance(result, Exception):
                vulnerabilities.append(result)

        return vulnerabilities

    async def _check_injection_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for basic injection vulnerabilities"""
        vulnerabilities = []

        try:
            # Get the main page to look for forms
            async with self.session.get(target) as response:
                content = await response.text()

                # Look for forms with input fields
                form_pattern = r'<form[^>]*>(.*?)</form>'
                input_pattern = r'<input[^>]*name=["']([^"']+)["']'

                forms = re.findall(form_pattern, content, re.IGNORECASE | re.DOTALL)

                for form_content in forms:
                    inputs = re.findall(input_pattern, form_content, re.IGNORECASE)

                    for input_name in inputs[:3]:  # Limit to first 3 inputs
                        # Test for reflected XSS
                        xss_vuln = await self._test_reflected_xss(target, input_name)
                        if xss_vuln:
                            vulnerabilities.append(xss_vuln)

                        # Basic SQL injection test (be very conservative)
                        sql_vuln = await self._test_sql_injection(target, input_name)
                        if sql_vuln:
                            vulnerabilities.append(sql_vuln)

        except Exception as e:
            pass  # Continue with other checks

        return vulnerabilities

    async def _test_reflected_xss(self, target: str, param_name: str) -> Optional[Dict[str, Any]]:
        """Test for reflected XSS vulnerability (conservative approach)"""
        try:
            # Use a safe, detectable payload
            test_payload = "SecAuditXSSTest123"

            # Try GET parameter
            test_url = f"{target}?{param_name}={test_payload}"
            async with self.session.get(test_url) as response:
                if response.status == 200:
                    content = await response.text()

                    # Check if our payload is reflected unencoded
                    if test_payload in content and not any(
                        encoded in content for encoded in [
                            'SecAuditXSSTest123'.replace('<', '&lt;'),
                            'SecAuditXSSTest123'.replace('>', '&gt;')
                        ]
                    ):
                        return {
                            'type': 'Reflected XSS',
                            'severity': 'HIGH',
                            'target': test_url,
                            'parameter': param_name,
                            'description': f'Reflected XSS vulnerability in parameter: {param_name}',
                            'evidence': f'Payload "{test_payload}" reflected unencoded',
                            'recommendation': 'Implement proper input validation and output encoding',
                            'cwe': 'CWE-79',
                            'timestamp': datetime.now().isoformat()
                        }

        except Exception:
            pass

        return None

    async def _test_sql_injection(self, target: str, param_name: str) -> Optional[Dict[str, Any]]:
        """Test for SQL injection vulnerability (very conservative)"""
        try:
            # Use time-based detection to avoid causing damage
            normal_payload = "1"
            error_payload = "1'"

            # Get baseline response time
            start_time = datetime.now()
            test_url = f"{target}?{param_name}={normal_payload}"
            async with self.session.get(test_url) as response:
                normal_response = await response.text()
            normal_time = (datetime.now() - start_time).total_seconds()

            # Test with error payload
            start_time = datetime.now()
            test_url = f"{target}?{param_name}={error_payload}"
            async with self.session.get(test_url) as response:
                error_response = await response.text()
            error_time = (datetime.now() - start_time).total_seconds()

            # Look for database error messages
            sql_error_patterns = [
                r'mysql.*error',
                r'sql.*error',
                r'postgresql.*error',
                r'ora-\d{5}',
                r'microsoft.*database',
                r'sqlite.*error'
            ]

            error_lower = error_response.lower()
            for pattern in sql_error_patterns:
                if re.search(pattern, error_lower) and not re.search(pattern, normal_response.lower()):
                    return {
                        'type': 'SQL Injection',
                        'severity': 'CRITICAL',
                        'target': target,
                        'parameter': param_name,
                        'description': f'SQL injection vulnerability detected in parameter: {param_name}',
                        'evidence': f'Database error message detected with payload: {error_payload}',
                        'recommendation': 'Implement parameterized queries and input validation',
                        'cwe': 'CWE-89',
                        'timestamp': datetime.now().isoformat()
                    }

        except Exception:
            pass

        return None

    async def _check_http_methods(self, target: str) -> List[Dict[str, Any]]:
        """Check for dangerous HTTP methods"""
        vulnerabilities = []

        dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT', 'PATCH']

        for method in dangerous_methods:
            try:
                async with self.session.request(method, target) as response:
                    if response.status not in [404, 405, 501]:  # Method not allowed/not implemented
                        vulnerabilities.append({
                            'type': 'HTTP Method',
                            'severity': 'MEDIUM',
                            'target': target,
                            'method': method,
                            'description': f'Potentially dangerous HTTP method enabled: {method}',
                            'status_code': response.status,
                            'recommendation': f'Disable {method} method if not required',
                            'cwe': 'CWE-749',
                            'timestamp': datetime.now().isoformat()
                        })

            except Exception:
                pass  # Method likely not supported

        return vulnerabilities

    async def _check_security_configurations(self, target: str) -> List[Dict[str, Any]]:
        """Check for security configuration issues"""
        vulnerabilities = []

        try:
            async with self.session.get(target) as response:
                headers = dict(response.headers)

                # Check for missing security headers (basic check)
                critical_headers = {
                    'x-frame-options': 'Clickjacking protection missing',
                    'x-content-type-options': 'MIME type sniffing protection missing',
                    'content-security-policy': 'Content Security Policy not implemented'
                }

                for header, description in critical_headers.items():
                    if header not in [k.lower() for k in headers.keys()]:
                        vulnerabilities.append({
                            'type': 'Security Configuration',
                            'severity': 'MEDIUM',
                            'target': target,
                            'description': description,
                            'missing_header': header,
                            'recommendation': f'Implement {header} security header',
                            'cwe': 'CWE-16',
                            'timestamp': datetime.now().isoformat()
                        })

                # Check for insecure protocols
                if target.startswith('http://'):
                    vulnerabilities.append({
                        'type': 'Insecure Protocol',
                        'severity': 'HIGH',
                        'target': target,
                        'description': 'Website accessible over unencrypted HTTP',
                        'recommendation': 'Implement HTTPS and redirect HTTP traffic',
                        'cwe': 'CWE-319',
                        'timestamp': datetime.now().isoformat()
                    })

        except Exception:
            pass

        return vulnerabilities
